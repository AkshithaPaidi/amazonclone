// Carousel class for reusable carousel functionality
class Carousel {
    constructor(element, options = {}) {
        this.container = element;
        this.track = element.querySelector('.carousel-track');
        this.slides = Array.from(this.track.children);
        this.nextButton = element.querySelector('.next');
        this.prevButton = element.querySelector('.prev');
        this.nav = element.querySelector('.carousel-nav');
        this.indicators = this.nav ? Array.from(this.nav.children) : [];

        // Options with defaults
        this.options = {
            slidesToShow: options.slidesToShow || 1,
            infinite: options.infinite !== undefined ? options.infinite : true,
            autoplay: options.autoplay || false,
            autoplayDelay: options.autoplayDelay || 5000,
            ...options
        };

        this.currentSlide = 0;
        this.slideWidth = this.container.clientWidth / this.options.slidesToShow;
        this.autoplayInterval = null;

        this.init();
    }

    init() {
        // Set initial positions
        this.slides.forEach((slide, index) => {
            slide.style.width = `${this.slideWidth}px`;
            this.moveToSlide(this.currentSlide, false);
        });

        // Event listeners
        if (this.nextButton) {
            this.nextButton.addEventListener('click', () => this.next());
        }
        if (this.prevButton) {
            this.prevButton.addEventListener('click', () => this.prev());
        }

        this.indicators.forEach((indicator, index) => {
            indicator.addEventListener('click', () => this.goToSlide(index));
        });

        // Touch events for mobile
        let startX = 0;
        let isDragging = false;
        let currentTranslate = 0;

        this.track.addEventListener('touchstart', (e) => {
            startX = e.touches[0].clientX;
            isDragging = true;
            currentTranslate = this.getCurrentTranslate();
        });

        this.track.addEventListener('touchmove', (e) => {
            if (!isDragging) return;
            const currentX = e.touches[0].clientX;
            const diff = currentX - startX;
            this.track.style.transform = `translateX(${currentTranslate + diff}px)`;
        });

        this.track.addEventListener('touchend', (e) => {
            isDragging = false;
            const endX = e.changedTouches[0].clientX;
            const diff = endX - startX;
            
            if (Math.abs(diff) > 50) {
                if (diff > 0) {
                    this.prev();
                } else {
                    this.next();
                }
            } else {
                this.moveToSlide(this.currentSlide);
            }
        });

        // Start autoplay if enabled
        if (this.options.autoplay) {
            this.startAutoplay();
            
            // Pause on hover
            this.container.addEventListener('mouseenter', () => this.stopAutoplay());
            this.container.addEventListener('mouseleave', () => this.startAutoplay());
        }

        // Update on window resize
        window.addEventListener('resize', () => {
            this.slideWidth = this.container.clientWidth / this.options.slidesToShow;
            this.slides.forEach(slide => {
                slide.style.width = `${this.slideWidth}px`;
            });
            this.moveToSlide(this.currentSlide, false);
        });
    }

    getCurrentTranslate() {
        const style = window.getComputedStyle(this.track);
        const matrix = new WebKitCSSMatrix(style.transform);
        return matrix.m41;
    }

    moveToSlide(index, animate = true) {
        const targetPosition = -index * this.slideWidth;
        
        if (!animate) {
            this.track.style.transition = 'none';
        }
        
        this.track.style.transform = `translateX(${targetPosition}px)`;
        
        if (!animate) {
            this.track.offsetHeight; // Force reflow
            this.track.style.transition = '';
        }

        // Update indicators
        this.indicators.forEach((indicator, i) => {
            indicator.classList.toggle('active', i === index);
        });
    }

    next() {
        if (this.currentSlide < this.slides.length - this.options.slidesToShow) {
            this.currentSlide++;
        } else if (this.options.infinite) {
            this.currentSlide = 0;
        }
        this.moveToSlide(this.currentSlide);
    }

    prev() {
        if (this.currentSlide > 0) {
            this.currentSlide--;
        } else if (this.options.infinite) {
            this.currentSlide = this.slides.length - this.options.slidesToShow;
        }
        this.moveToSlide(this.currentSlide);
    }

    goToSlide(index) {
        this.currentSlide = index;
        this.moveToSlide(this.currentSlide);
    }

    startAutoplay() {
        if (this.options.autoplay) {
            this.autoplayInterval = setInterval(() => {
                this.next();
            }, this.options.autoplayDelay);
        }
    }

    stopAutoplay() {
        if (this.autoplayInterval) {
            clearInterval(this.autoplayInterval);
            this.autoplayInterval = null;
        }
    }
}

document.addEventListener('DOMContentLoaded', () => {
    // Delivery and Location functionality
    const deliveryLocation = document.getElementById('delivery-location');
    const addressModal = document.getElementById('address-modal');
    // Side Navigation functionality
    const hamburgerMenu = document.querySelector('.nav-hamburger');
    const sideNav = document.querySelector('.side-nav');
    const sideNavOverlay = document.querySelector('.side-nav-overlay');
    const sideNavClose = document.querySelector('.side-nav-close');
    const sideNavSections = document.querySelectorAll('.side-nav-section');

    function openSideNav() {
        sideNav.classList.add('active');
        sideNavOverlay.classList.add('active');
        document.body.style.overflow = 'hidden';
    }

    function closeSideNav() {
        sideNav.classList.remove('active');
        sideNavOverlay.classList.remove('active');
        document.body.style.overflow = '';
    }

    hamburgerMenu.addEventListener('click', openSideNav);
    sideNavClose.addEventListener('click', closeSideNav);
    sideNavOverlay.addEventListener('click', closeSideNav);

    // Handle sub-menu navigation
    sideNavSections.forEach(section => {
        const links = section.querySelectorAll('a');
        links.forEach(link => {
            if (link.querySelector('.fas.fa-chevron-right')) {
                link.addEventListener('click', (e) => {
                    e.preventDefault();
                    // In a real implementation, this would load sub-categories
                    alert('Loading sub-categories for: ' + link.textContent.trim());
                });
            }
        });
    });

    /* Navigation interactions with timeouts for better UX */
    const modalClose = document.querySelector('.modal-close');
    const zipCodeInput = document.getElementById('zip-code');
    const applyZipButton = document.querySelector('.apply-button');
    const useLocationButton = document.querySelector('.location-button');

    // Delivery date calculation
    function calculateDeliveryDate(zipCode) {
        const today = new Date();
        const processingDays = 1; // Basic processing time
        
        // Calculate delivery based on zip code distance (mock implementation)
        const firstDigit = parseInt(zipCode.charAt(0));
        let shippingDays = 2; // Default Prime shipping

        if (firstDigit <= 3) { // East coast
            shippingDays = 1;
        } else if (firstDigit >= 8) { // West coast
            shippingDays = 3;
        }

        const deliveryDate = new Date(today);
        deliveryDate.setDate(today.getDate() + processingDays + shippingDays);

        // Skip weekends
        while (deliveryDate.getDay() === 0 || deliveryDate.getDay() === 6) {
            deliveryDate.setDate(deliveryDate.getDate() + 1);
        }

        return deliveryDate;
    }

    function formatDeliveryDate(date) {
        const options = { weekday: 'short', month: 'short', day: 'numeric' };
        return date.toLocaleDateString('en-US', options);
    }

    function updateDeliveryInfo(zipCode) {
        const deliveryDate = calculateDeliveryDate(zipCode);
        const formattedDate = formatDeliveryDate(deliveryDate);
        
        // Update delivery location display
        const locationText = document.querySelector('.nav-location strong');
        locationText.textContent = `Deliver to ${zipCode}`;

        // Update delivery badges on products
        document.querySelectorAll('.delivery-date').forEach(badge => {
            badge.textContent = `Get it by ${formattedDate}`;
        });

        // Store zip code
        localStorage.setItem('delivery_zipcode', zipCode);
    }

    // Address modal event listeners
    deliveryLocation.addEventListener('click', () => {
        addressModal.style.display = 'block';
    });

    modalClose.addEventListener('click', () => {
        addressModal.style.display = 'none';
    });

    window.addEventListener('click', (e) => {
        if (e.target === addressModal) {
            addressModal.style.display = 'none';
        }
    });

    // Zip code validation and application
    zipCodeInput.addEventListener('input', (e) => {
        e.target.value = e.target.value.replace(/[^0-9]/g, '');
    });

    applyZipButton.addEventListener('click', () => {
        const zipCode = zipCodeInput.value;
        if (/^\d{5}$/.test(zipCode)) {
            updateDeliveryInfo(zipCode);
            addressModal.style.display = 'none';
        } else {
            alert('Please enter a valid 5-digit ZIP code');
        }
    });

    // Geolocation
    useLocationButton.addEventListener('click', () => {
        if (navigator.geolocation) {
            useLocationButton.disabled = true;
            useLocationButton.textContent = 'Detecting location...';
            
            navigator.geolocation.getCurrentPosition(
                (position) => {
                    // In a real implementation, we would use a geocoding service
                    // to convert coordinates to zip code. For demo, use a mock zip:
                    const mockZipCode = '10001';
                    updateDeliveryInfo(mockZipCode);
                    addressModal.style.display = 'none';
                },
                (error) => {
                    alert('Unable to detect location. Please enter your ZIP code.');
                },
                { timeout: 10000 }
            );
            
            useLocationButton.disabled = false;
            useLocationButton.innerHTML = '<i class="fas fa-location-arrow"></i> Use my current location';
        } else {
            alert('Geolocation is not supported by your browser');
        }
    });

    // Load saved zip code if available
    const savedZipCode = localStorage.getItem('delivery_zipcode');
    if (savedZipCode) {
        updateDeliveryInfo(savedZipCode);
    }

    // Cart functionality
    let cartCount = 0;
    let cartItems = [];
    const cartCountElement = document.querySelector('.cart-count');
    const cartIcon = document.querySelector('.nav-cart');
    const cartDropdown = document.querySelector('.cart-dropdown');
    const emptyCart = document.querySelector('.empty-cart');
    const cartItemsContainer = document.querySelector('.cart-items');

    // Handle cart hover
    let cartTimeout;
    cartIcon.addEventListener('mouseenter', () => {
        clearTimeout(cartTimeout);
        cartDropdown.style.display = 'block';
    });

    cartIcon.addEventListener('mouseleave', () => {
        cartTimeout = setTimeout(() => {
            if (!cartDropdown.matches(':hover')) {
                cartDropdown.style.display = 'none';
            }
        }, 200);
    });

    cartDropdown.addEventListener('mouseleave', () => {
        cartTimeout = setTimeout(() => {
            cartDropdown.style.display = 'none';
        }, 200);
    });

    // Search functionality with enhanced features
    const searchInput = document.querySelector('.search-input');
    const searchButton = document.querySelector('.search-button');
    const searchSelect = document.querySelector('.nav-search-select select');
    let searchHistory = JSON.parse(localStorage.getItem('searchHistory') || '[]');

    // Create search suggestions container
    const searchSuggestions = document.createElement('div');
    searchSuggestions.className = 'search-suggestions';
    searchInput.parentElement.appendChild(searchSuggestions);

    function updateSearchSuggestions(query) {
        if (query.length < 2) {
            searchSuggestions.style.display = 'none';
            return;
        }

        const suggestions = searchHistory
            .filter(item => item.toLowerCase().includes(query.toLowerCase()))
            .slice(0, 5);

        if (suggestions.length > 0) {
            searchSuggestions.innerHTML = suggestions
                .map(suggestion => `
                    <div class="suggestion-item">
                        <i class="fas fa-history"></i>
                        <span>${suggestion}</span>
                    </div>
                `).join('');
            searchSuggestions.style.display = 'block';
        } else {
            searchSuggestions.style.display = 'none';
        }
    }

    searchInput.addEventListener('input', (e) => {
        updateSearchSuggestions(e.target.value);
    });

    searchInput.addEventListener('focus', () => {
        if (searchInput.value.length >= 2) {
            updateSearchSuggestions(searchInput.value);
        }
    });

    document.addEventListener('click', (e) => {
        if (!searchInput.contains(e.target) && !searchSuggestions.contains(e.target)) {
            searchSuggestions.style.display = 'none';
        }
    });

    function handleSearch() {
        const searchTerm = searchInput.value.trim();
        if (searchTerm) {
            // Add to search history
            if (!searchHistory.includes(searchTerm)) {
                searchHistory.unshift(searchTerm);
                searchHistory = searchHistory.slice(0, 10); // Keep only last 10 searches
                localStorage.setItem('searchHistory', JSON.stringify(searchHistory));
            }
            alert(`Searching in ${searchSelect.value} for: ${searchTerm}`);
        }
    }

    searchButton.addEventListener('click', handleSearch);
    searchInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            handleSearch();
        }
    });

    // Language and currency handling
    const languageOptions = document.querySelectorAll('input[name="language"]');
    const currencySelect = document.querySelector('.currency-selector select');

    languageOptions.forEach(option => {
        option.addEventListener('change', (e) => {
            const selectedLang = e.target.value;
            localStorage.setItem('preferred_language', selectedLang);
            // In a real implementation, this would trigger a page reload with the new language
            alert(`Language would change to: ${selectedLang}`);
        });
    });

    currencySelect.addEventListener('change', (e) => {
        const selectedCurrency = e.target.value;
        localStorage.setItem('preferred_currency', selectedCurrency);
        // In a real implementation, this would update all prices on the page
        alert(`Currency would change to: ${selectedCurrency}`);
    });

    // Account dropdown handling
    const signInButton = document.querySelector('.sign-in-button');
    const signUpButton = document.querySelector('.signup-button');
    
    signInButton.addEventListener('click', () => {
        // In a real implementation, this would open a sign-in modal or redirect to sign-in page
        alert('Sign in functionality would open here');
    });

    signUpButton.addEventListener('click', () => {
        // In a real implementation, this would open a sign-up modal or redirect to sign-up page
        alert('Sign up functionality would open here');
    });

    // Back to top functionality with smooth scroll
    const backToTop = document.querySelector('.back-to-top');
    window.addEventListener('scroll', () => {
        if (window.scrollY > 300) {
            backToTop.style.display = 'block';
        } else {
            backToTop.style.display = 'none';
        }
    });

    // Navigation interactions with timeouts for better UX
    const navItems = document.querySelectorAll('.nav-signin, .nav-orders, .nav-language');
    const dropdowns = document.querySelectorAll('.dropdown-menu');
    
    let activeTimeout;

    navItems.forEach(item => {
        const dropdown = item.querySelector('.dropdown-menu');
        if (!dropdown) return;

        item.addEventListener('mouseenter', () => {
            clearTimeout(activeTimeout);
            dropdowns.forEach(d => d.style.display = 'none');
            dropdown.style.display = 'block';
        });

        item.addEventListener('mouseleave', () => {
            activeTimeout = setTimeout(() => {
                if (!dropdown.matches(':hover')) {
                    dropdown.style.display = 'none';
                }
            }, 200);
        });

        if (dropdown) {
            dropdown.addEventListener('mouseleave', () => {
                activeTimeout = setTimeout(() => {
                    dropdown.style.display = 'none';
                }, 200);
            });
        }
    });

    // Language selector
    const languageSelector = document.querySelector('.language-selector');
    languageSelector.addEventListener('click', () => {
        alert('Language selection options would appear here');
    });

    // Add hover effect for product cards
    const productCards = document.querySelectorAll('.product-card');
    productCards.forEach(card => {
        card.addEventListener('mouseenter', () => {
            card.style.transform = 'translateY(-2px)';
            card.style.boxShadow = '0 4px 8px rgba(0,0,0,0.1)';
        });
        
        card.addEventListener('mouseleave', () => {
            card.style.transform = 'none';
            card.style.boxShadow = 'none';
        });
    });

    // Product filtering functionality
    const filterCheckboxes = document.querySelectorAll('.filter-list input[type="checkbox"]');
    const sortSelect = document.getElementById('sort-select');
    const priceRangeInputs = document.querySelectorAll('.price-range input');
    const goButton = document.querySelector('.go-button');
    const starRatings = document.querySelectorAll('.star-rating');

    // Sample product data
    const products = [
        { id: 1, name: 'Gaming Laptop', price: 899.99, rating: 4.5, department: 'electronics', condition: 'new' },
        { id: 2, name: 'Wireless Headphones', price: 249.99, rating: 5, department: 'electronics', condition: 'new' },
        // Add more products as needed
    ];

    let activeFilters = {
        departments: new Set(),
        minRating: 0,
        priceRange: { min: 0, max: Infinity },
        conditions: new Set()
    };

    function applyFilters() {
        const filteredProducts = products.filter(product => {
            const departmentMatch = activeFilters.departments.size === 0 || 
                                  activeFilters.departments.has(product.department);
            const ratingMatch = product.rating >= activeFilters.minRating;
            const priceMatch = product.price >= activeFilters.priceRange.min && 
                             product.price <= activeFilters.priceRange.max;
            const conditionMatch = activeFilters.conditions.size === 0 || 
                                 activeFilters.conditions.has(product.condition);

            return departmentMatch && ratingMatch && priceMatch && conditionMatch;
        });

        // Sort products
        const sortValue = sortSelect.value;
        filteredProducts.sort((a, b) => {
            switch(sortValue) {
                case 'price-low':
                    return a.price - b.price;
                case 'price-high':
                    return b.price - a.price;
                case 'rating':
                    return b.rating - a.rating;
                case 'newest':
                    return b.id - a.id;
                default: // featured
                    return 0;
            }
        });

        updateProductDisplay(filteredProducts);
    }

    function updateProductDisplay(filteredProducts) {
        // Update results count
        const resultsCount = document.querySelector('.results-count');
        resultsCount.textContent = `1-${Math.min(filteredProducts.length, 16)} of ${filteredProducts.length} results`;

        // In a real implementation, this would update the product grid
        console.log('Filtered products:', filteredProducts);
    }

    // Event listeners for filters
    filterCheckboxes.forEach(checkbox => {
        checkbox.addEventListener('change', (e) => {
            const filterType = checkbox.closest('.filter-section').querySelector('h3').textContent.toLowerCase();
            const value = checkbox.value;

            if (filterType === 'department') {
                if (checkbox.checked) {
                    activeFilters.departments.add(value);
                } else {
                    activeFilters.departments.delete(value);
                }
            } else if (filterType === 'condition') {
                if (checkbox.checked) {
                    activeFilters.conditions.add(value);
                } else {
                    activeFilters.conditions.delete(value);
                }
            }

            applyFilters();
        });
    });

    starRatings.forEach((rating, index) => {
        rating.addEventListener('click', (e) => {
            e.preventDefault();
            const stars = 5 - index;
            activeFilters.minRating = stars;
            applyFilters();
        });
    });

    sortSelect.addEventListener('change', applyFilters);

    goButton.addEventListener('click', () => {
        const minPrice = parseFloat(priceRangeInputs[0].value) || 0;
        const maxPrice = parseFloat(priceRangeInputs[1].value) || Infinity;
        
        activeFilters.priceRange = {
            min: minPrice,
            max: maxPrice
        };
        
        applyFilters();
    });

    // Simulate loading more products
    const seeMoreLinks = document.querySelectorAll('.see-more');
    seeMoreLinks.forEach(link => {
        link.addEventListener('click', (e) => {
            e.preventDefault();
            alert('Loading more items...');
        });
    });

    // Side Navigation functionality
    hamburgerMenu.addEventListener('click', () => {
        document.querySelector('.side-nav').classList.add('active');
        document.querySelector('.side-nav-overlay').classList.add('active');
        document.body.style.overflow = 'hidden';
    });

    document.querySelector('.side-nav-close').addEventListener('click', () => {
        document.querySelector('.side-nav').classList.remove('active');
        document.querySelector('.side-nav-overlay').classList.remove('active');
        document.body.style.overflow = '';
    });

    document.querySelector('.side-nav-overlay').addEventListener('click', () => {
        document.querySelector('.side-nav').classList.remove('active');
        document.querySelector('.side-nav-overlay').classList.remove('active');
        document.body.style.overflow = '';
    });

    // Handle sub-menu navigation
    document.querySelectorAll('.side-nav-section a').forEach(link => {
        if (link.querySelector('.fas.fa-chevron-right')) {
            link.addEventListener('click', (e) => {
                e.preventDefault();
            });
        }
    });

    // Carousel class for reusable carousel functionality
    class Carousel {
        constructor(element, options = {}) {
            this.container = element;
            this.track = element.querySelector('.carousel-track');
            this.slides = Array.from(this.track.children);
            this.nextButton = element.querySelector('.next');
            this.prevButton = element.querySelector('.prev');
            this.nav = element.querySelector('.carousel-nav');
            this.indicators = this.nav ? Array.from(this.nav.children) : [];

            // Options with defaults
            this.options = {
                slidesToShow: options.slidesToShow || 1,
                infinite: options.infinite !== undefined ? options.infinite : true,
                autoplay: options.autoplay || false,
                autoplayDelay: options.autoplayDelay || 5000,
                ...options
            };

            this.currentSlide = 0;
            this.slideWidth = this.container.clientWidth / this.options.slidesToShow;
            this.autoplayInterval = null;

            this.init();
        }

        init() {
            // Set initial positions
            this.slides.forEach((slide, index) => {
                slide.style.width = `${this.slideWidth}px`;
                this.moveToSlide(this.currentSlide, false);
            });

            // Event listeners
            if (this.nextButton) {
                this.nextButton.addEventListener('click', () => this.next());
            }
            if (this.prevButton) {
                this.prevButton.addEventListener('click', () => this.prev());
            }

            this.indicators.forEach((indicator, index) => {
                indicator.addEventListener('click', () => this.goToSlide(index));
            });

            // Touch events for mobile
            let startX = 0;
            let isDragging = false;
            let currentTranslate = 0;

            this.track.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                isDragging = true;
                currentTranslate = this.getCurrentTranslate();
            });

            this.track.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                const currentX = e.touches[0].clientX;
                const diff = currentX - startX;
                this.track.style.transform = `translateX(${currentTranslate + diff}px)`;
            });

            this.track.addEventListener('touchend', (e) => {
                isDragging = false;
                const endX = e.changedTouches[0].clientX;
                const diff = endX - startX;
                
                if (Math.abs(diff) > 50) {
                    if (diff > 0) {
                        this.prev();
                    } else {
                        this.next();
                    }
                } else {
                    this.moveToSlide(this.currentSlide);
                }
            });

            // Start autoplay if enabled
            if (this.options.autoplay) {
                this.startAutoplay();
                
                // Pause on hover
                this.container.addEventListener('mouseenter', () => this.stopAutoplay());
                this.container.addEventListener('mouseleave', () => this.startAutoplay());
            }

            // Update on window resize
            window.addEventListener('resize', () => {
                this.slideWidth = this.container.clientWidth / this.options.slidesToShow;
                this.slides.forEach(slide => {
                    slide.style.width = `${this.slideWidth}px`;
                });
                this.moveToSlide(this.currentSlide, false);
            });
        }

        getCurrentTranslate() {
            const style = window.getComputedStyle(this.track);
            const matrix = new WebKitCSSMatrix(style.transform);
            return matrix.m41;
        }

        moveToSlide(index, animate = true) {
            const targetPosition = -index * this.slideWidth;
            
            if (!animate) {
                this.track.style.transition = 'none';
            }
            
            this.track.style.transform = `translateX(${targetPosition}px)`;
            
            if (!animate) {
                this.track.offsetHeight; // Force reflow
                this.track.style.transition = '';
            }

            // Update indicators
            this.indicators.forEach((indicator, i) => {
                indicator.classList.toggle('active', i === index);
            });
        }

        next() {
            if (this.currentSlide < this.slides.length - this.options.slidesToShow) {
                this.currentSlide++;
            } else if (this.options.infinite) {
                this.currentSlide = 0;
            }
            this.moveToSlide(this.currentSlide);
        }

        prev() {
            if (this.currentSlide > 0) {
                this.currentSlide--;
            } else if (this.options.infinite) {
                this.currentSlide = this.slides.length - this.options.slidesToShow;
            }
            this.moveToSlide(this.currentSlide);
        }

        goToSlide(index) {
            this.currentSlide = index;
            this.moveToSlide(this.currentSlide);
        }

        startAutoplay() {
            if (this.options.autoplay) {
                this.autoplayInterval = setInterval(() => {
                    this.next();
                }, this.options.autoplayDelay);
            }
        }

        stopAutoplay() {
            if (this.autoplayInterval) {
                clearInterval(this.autoplayInterval);
                this.autoplayInterval = null;
            }
        }
    }

                const category = link.textContent.trim();
                alert(`Loading sub-categories for: ${category}`);
            });
        }
    });

    // Add smooth scrolling for Back to Top
    document.querySelector('.back-to-top a').addEventListener('click', (e) => {
        e.preventDefault();
        window.scrollTo({
            top: 0,
            behavior: 'smooth'
        });
    });

    // Initialize carousels
    const heroCarousel = new Carousel(document.querySelector('.hero-carousel'), {
        infinite: true,
        autoplay: true,
        autoplayDelay: 5000
    });

    const recommendationsCarousel = new Carousel(document.querySelector('.recommendations-carousel'), {
        slidesToShow: 5,
        infinite: false,
        autoplay: false
    });
});